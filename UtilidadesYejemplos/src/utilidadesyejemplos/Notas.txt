    
    ----------------------------------------------------------------------------
    UNIDAD:5
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    COMENTARIOS ATRIBUTOS
    ----------------------------------------------------------------------------

      - Algunos atributos no van a cambiar nunca de valor una vez que se
      fabrique el vehículo -> inmutables,una vez que se le asigne un valor ya
      no podrá ser cambiado ->final - Otros, podrán ir modificando su valor a
      lo largo del tiempo - El nombre de los atributos constantes (final) se
      escribe con todas las letras en mayúsculas, separando las palabras con el
      caracter _ Aunque hay una excepción - El modificador static, hace que el
      atributo sea común para todos los objetos de una misma clase, es decir,
      todos los atributos de la clase, compartirán ese mismo atributo con el
      mismo valor ->atributo estático o atributo de clase o varible de clase.
     

    
      El convenio estándar indica que aquellos elementos que sean de tipo
      constante (final) deberían seguir la nomenclatura de usar siempre
      mayúsculas y guión bajo para separa cada palabra, sin embargo, hemos
      visto atributos constantes usando "lower camel case" en lugar de las
      mayúsculas, Es habitual que cuando se trate de ->atributos de objeto (no
      de variables locales) se use este modelo para distinguirlo de las
      constantes que sean atributos de clase; Los atributos de clase,
      normalmente serán públicos pues contienen información sobre
      configuraciones,restricciones, que es interesante qeu sea visible desde
      fuera de la clase.
     
     
     

    
      MODIFICADOR STATIC. Gracias al modificador static, NO se creará un
      atributo vehiculosCreados, cada vez que se instancie un objeto vehiculo.
      Si no que este atributo existirá antes de la creación de ningún objeto.
     

    
      ATRIBUTOS DE CLASE CONSTANTE. Podría interesarnos tener almacenada cuál
      es la máxima y mínima capacidad del depósito de combustible para nuestro
      vehículo. Nos tocaría a nosotros indicar cuál sería la cantidad mínima y
      máxima y si no se cumplen estas condiciones no permitimos que se cree ese
      objeto. Son unos valores límite ya establecidos, parece más que
      justificado que se trate de atributos de clase y no de objeto. Se han
      declarado como public, Porque se trata de valores límite que son de
      interés para otros programadorque vaya a utilizar esta clase. Aunque se
      puede tener acceso a su valor, no podrán ser modificados por o que no hay
      riesgo de integridad.Es uno de los pocos casos en los que es positivo
      evitar la privacidad. Pues estamos dando información útil al usuario de
      esta clase y además no pueden ser modificados.
     

    ----------------------------------------------------------------------------
    COMENTARIOS MÉTODOS
    ----------------------------------------------------------------------------
    En la cabecera del método, aunque no es obligatorio, sí puede ser conveniente
    Declarar una lista de nobres de excepciones separadas por comas, utilizamos
    la palabra reservada "throws" seguida de dicha lista.

    Un método "static" (método estático o de clase) es un método desde cuya impl
    ementación no se accede a atributos de objeto. Desde este tipo de métodos só
    lo se puede acceder a atributos de la clase (estáticos) Estos métodos pueden
    ser invocados sin necesidad de tener un objeto de la clase instanciado.

    La llamada a métodos estáticos, se hace normalmente usando el nombre de la 
    propia clase y no el de una instancia (objeto)Pues se trata, realmente de 
    un método de clase.

    Un método "final" es un método que no permite ser redefinido o sobreescrito
    por clases descendientes.

    El modificador "abstract" sirve para indicar que un método es abstracto.
    El método no tendrá implementación, solo la declaración terminada en punto y
    coma,en lugar de las llaves del cuerpo.

    La implementación será realizada en las clases descendientes. Un método sólo
    puede ser declarado como "abstract" si se encuenta dentro de una clase abstract

    El modificador "synchronized" obligará a que cuando un proceso esté ejecutando
    éste método, el resto de procesos que tengan que llamar a ese mismo método 
    deberán esperar a que el otro proceso termine. Puede ser útil si sabes que un
    determinado método va a poder ser llamado concurrentemente por varios procesos
    a la vez.

    En Java, *el paso de parámetros es siempre por valor* excepto en el caso de
    los tipos referenciados (por ejemplo objetos) en cuyo caso se está pasando 
    efectivamente una referencia.

    Varags-> permite que un método pueda tener un número variable de parámetros.
    Para utilizar este mecanismo se coloca un 1-tipo, 2-unos puntos suspensivos (...)
    espacio en blanco y a continuación el 3-nombre del parámetro que aglutinará
    la lista de argumentos variables.
    Es posible utilizar varags con parámetros fijos. La lista de parámetros variable
    debe aparecer al final (y solo puede aparecer una)

    Se permite añadir el modificador "final" a los parámetros de un método, para
    que el parámetro no pueda ser modificado.

    El tipo de valor que devuelva la sentencia return debería ser del mismo tipo 
    o de un tipo COMPATIBLE con el tipo del valor de retorno definido en la cabecera
    del método.

    Se recomienda NO incluir mas de un return en un método, que debería ir al final
    del mismo, como salida natural.
    
    La recomendación es usar this.nombre cada vez que usemos en un método-> mejora
    la legibilidad.

    Al llevar a cabo comprobaciones sobre parámetros que son referencias a objetos
    (por ejemplo String o LocalDate) debes tener la precaución de comprobar primero
    que NO son "null" porque si intentas acceder a un miembro(método o atributo) de
    una referencia null, se produce un error saltando una excepción NullPointerException.
    Cuando sepas que no es null, puedes intentar acceder al método que consideres
    oportuno.

    Se puede llamar a un constructor de una clase desde otro constructor de la misma clase:
    con el método this(), dentro de un cosntructor sirve para hacer una llmada al 
    constructor de la misma clase cuya lista de argumentos coincida con los que se le pasa a
    this().
    La única restricción es que, de invocar a this(), dentro de un constructor,
    ésta tiene que ser obligatoriamente la primera sentencia del nuevo constructor.

    Podemos tener un constructor que se encargue de todo el "trabajo duro" de comprobaciones
    y asignaciones y el resto de constructores (que normalmente tendrán una menor cantidad de parámetros) 
    harán uso de este constructor más "inteligente", evitando tener que repetir el código 
    que éste contiene.

    Es conveniente tener valores por omisión(así como máximos y mínimos) en 
    constantes de clase para no tener que escribirlos una y otra vez a lo largo del código.

    Método de fábrica:
        -Debe ser estático.
        -Devolver un objeto del mismo tipo que la clase a la que pertenece.
        -Llamar a algún constructor de la clase con el operador new.
        -Devolver la referencia obtenida con el operador new mediante una sentencia return.

    Cada vez que utilicemos un método de una clase (incluido el constructor) debemos revisar si existe la
    posibilidad de que puedan lanzarse excepciones desde ese método en caso afirmativo:
    Habrá que encerrar la llamada a ese método en un bloque try-catch


    ----------------------------------------------------------------------------
    UNIDAD:6
    ----------------------------------------------------------------------------
    Hasta ahora los métodos de tipo get devolvían tipos primitivos, es decir
    copias del contenido pero los atributos seguían a salvo.
    Al tener objetos dentro de las clases y no solo tipos primitivos hay que obrar
    con mucho cuidado. Si un método de la clase devuelve directamente un objeto que
    es un atributo, estarás ofreciendo directamente una referencia a un objeto, que
    probablemente hayas definido como privado, ¡Estás volviendo a hacer público un 
    atributo que inicialmente era privado!
    ¿Cómo evitar esta situación?:
    - Devolver siempre tipos primitivos.
    - Obligar a que los objetos contenidos que vayan a ser devueltos sean de clases inmutables
    con lo cual aunque se tenga acceso a ellos, no podrán ser modificados (String y LocalDate son inmutables
    ->Una vez que se crea una instancia de estos objetos(String y LocalDate), su valor no puede ser modifcado)
    ->Los enum son un tipo especial de clase que define un conjunto de constantes.->Los valores de un enum son inmutables.   
    - Crear un nuevo objeto, que sea una copia del atributo que quieres devolver
    y utilizar ese objeto como valor de retorno. Es decir, crear una copia del objeto
    especialmente para devolverlo.
    
    Sólo se crean objetos cuando se llama a un constructor, (uso de new) o bien
    cuando se invocan métodos que sabemos positivamente que devuelven nuevas instancias
    de objetos.Si realizas asignaciones o pasos de parámetros no se están copiando
    o pasando copias de los objetos, sino simplemente las referencias y por tanto
    se tratará siempre del mismo objeto

    Del mismo modo ocurre, si nuestra clase dispone de métodos set qeu reciben como
    parámetros referencias objetos, se producirá exactamente el mismo fenómeno:
    si no se realiza una copia del objeto al que se hace referencia, es posible
    que ese objeto en el futuro pueda ser modificado desde fuera de la clase

    Los métodos estáticos o de clase no pueden ser sobrescritos.

    ----------------------------------------------------------------------------
    Operador instanceof
    ----------------------------------------------------------------------------
    Como ya has visto, en principio no se puede acceder a los miembros específicos de una
    subclase a través de una referencia a una superclase.
    Si deseas tener acceso a todos los métodos y atributos específicos del objeto 
    subclase tendrás que realizar una conversión explícita (casting) que convierta
    la referencia más general (superclase) en la del tipo específico del objeto
    (sublcase)

    Para que pueda llevarse a cabo una conversión entre distintas clases es obligatorio
    que exista una relación de herencia entre ellas (una debe ser clase derivada    
    de la otra)
